<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <title>เอกสาร</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #EAEAEA; min-height: 100vh; display: flex; flex-direction: column; }

    .toolbar {
      position: sticky; top: 0; z-index: 10;
      display: flex; align-items: center; gap: 8px;
      padding: 10px 14px;
      background: #fff;
      border-bottom: 1px solid #ddd;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    }
    .toolbar .doc-name {
      flex: 1; font-size: 0.88em; font-weight: 600; color: #333;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .btn {
      display: inline-flex; align-items: center; gap: 5px;
      padding: 8px 14px; border-radius: 10px; font-size: 0.82em; font-weight: 600;
      text-decoration: none; border: none; cursor: pointer;
      white-space: nowrap; flex-shrink: 0; transition: opacity 0.15s;
    }
    .btn:active { opacity: 0.7; }
    .btn-save { background: #0D99FF; color: #fff; }
    .btn-close { background: #f0f0f0; color: #555; }

    .page-info {
      text-align: center; padding: 6px; font-size: 0.75em; color: #888; background: #EAEAEA;
      position: sticky; top: 52px; z-index: 9;
    }

    .pages {
      flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch;
      display: flex; flex-direction: column; align-items: center;
      padding: 8px 0 80px;
      gap: 8px;
    }
    .pages canvas {
      display: block; width: 100%; max-width: 100%;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      background: #fff;
    }

    .loading-screen {
      flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: #999; gap: 12px; padding: 40px;
    }
    .spinner {
      width: 32px; height: 32px; border: 3px solid #e0e0e0; border-top-color: #0D99FF;
      border-radius: 50%; animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .toast {
      position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.82); color: #fff; padding: 10px 22px;
      border-radius: 22px; font-size: 0.85em; z-index: 100;
      opacity: 0; transition: opacity 0.3s; pointer-events: none;
    }
    .toast.show { opacity: 1; }

    .dl-overlay {
      display: none; position: fixed; inset: 0;
      background: rgba(0,0,0,0.5); z-index: 50;
      flex-direction: column; align-items: center; justify-content: center;
    }
    .dl-overlay.show { display: flex; }
    .dl-box {
      background: #fff; border-radius: 16px; padding: 28px 32px;
      text-align: center; max-width: 280px;
    }
    .dl-box .spinner { margin: 0 auto 12px; }
    .dl-box p { font-size: 0.9em; color: #555; }

    /* Image viewer for non-PDF files */
    .img-viewer {
      flex: 1; overflow: auto; -webkit-overflow-scrolling: touch;
      display: flex; align-items: flex-start; justify-content: center;
      padding: 8px 0 80px; background: #EAEAEA;
    }
    .img-viewer img {
      width: 100%; display: block; background: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <div class="doc-name" id="docName">เอกสาร</div>
    <button class="btn btn-save" id="btnSave" onclick="saveAsImage()">
      <svg width="15" height="15" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path d="M12 4v12m0 0l-4-4m4 4l4-4M4 18h16"/></svg>
      บันทึกรูป
    </button>
    <button class="btn btn-close" onclick="closePage()">ปิด</button>
  </div>
  <div id="pageInfo" class="page-info" style="display:none;"></div>
  <div id="container">
    <div class="loading-screen" id="loadingScreen">
      <div class="spinner"></div>
      <div>กำลังโหลดเอกสาร...</div>
    </div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="dl-overlay" id="dlOverlay">
    <div class="dl-box">
      <div class="spinner"></div>
      <p id="dlText">กำลังบันทึกรูปภาพ...</p>
    </div>
  </div>

  <script src="/liff/env.js"></script>
  <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    const params = new URLSearchParams(window.location.search);
    const fileId = params.get('fileId') || '';
    const mode = params.get('mode');
    const docName = params.get('name') || 'เอกสาร';
    const apiBase = window.location.origin;
    let pdfDoc = null;
    let renderedCanvases = [];
    let isImageFile = false;
    let userName = '';

    document.getElementById('docName').textContent = docName;

    // pdf.js worker
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }

    function showToast(msg) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), 2500);
    }

    function closePage() {
      if (window.history.length > 1) {
        window.history.back();
      } else {
        try { liff.closeWindow(); } catch (e) {}
        window.close();
      }
    }

    // Render a single PDF page to a canvas at device-fitting width
    async function renderPage(page, pageNum) {
      const containerWidth = window.innerWidth;
      const scale = (containerWidth * window.devicePixelRatio) / page.getViewport({ scale: 1 }).width;
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement('canvas');
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      canvas.style.width = containerWidth + 'px';
      canvas.style.height = (viewport.height / window.devicePixelRatio) + 'px';
      canvas.dataset.page = pageNum;

      const ctx = canvas.getContext('2d');
      await page.render({ canvasContext: ctx, viewport }).promise;
      addWatermark(canvas);
      return canvas;
    }

    function addWatermark(canvas) {
      const ctx = canvas.getContext('2d');
      const text = userName ? `COPY — ${userName}` : 'COPY';
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#000000';
      const fontSize = Math.max(canvas.width / 12, 30);
      ctx.font = `bold ${fontSize}px sans-serif`;
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(-Math.PI / 6);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // Repeat watermark across the page
      for (let y = -canvas.height; y < canvas.height; y += fontSize * 3) {
        for (let x = -canvas.width; x < canvas.width; x += ctx.measureText(text).width + fontSize * 2) {
          ctx.fillText(text, x, y);
        }
      }
      ctx.restore();
    }

    async function loadPDF(url) {
      const container = document.getElementById('container');
      const loading = document.getElementById('loadingScreen');
      const pageInfo = document.getElementById('pageInfo');

      try {
        // Fetch file once, check content-type from response header (no extra HEAD request)
        const res = await fetch(url);
        const contentType = res.headers.get('content-type') || '';

        if (contentType.startsWith('image/')) {
          isImageFile = true;
          const blob = await res.blob();
          loading.style.display = 'none';
          container.className = 'pages';
          container.innerHTML = '';
          // Draw image on canvas with watermark
          const imgEl = new Image();
          imgEl.src = URL.createObjectURL(blob);
          await new Promise(r => { imgEl.onload = r; });
          const cw = window.innerWidth;
          const scale = (cw * window.devicePixelRatio) / imgEl.naturalWidth;
          const canvas = document.createElement('canvas');
          canvas.width = imgEl.naturalWidth * scale;
          canvas.height = imgEl.naturalHeight * scale;
          canvas.style.width = cw + 'px';
          canvas.style.height = (canvas.height / window.devicePixelRatio) + 'px';
          const ictx = canvas.getContext('2d');
          ictx.drawImage(imgEl, 0, 0, canvas.width, canvas.height);
          addWatermark(canvas);
          container.appendChild(canvas);
          renderedCanvases.push(canvas);
          return;
        }

        // Load PDF from already-fetched data (no second request)
        const arrayBuffer = await res.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        pdfDoc = pdf;
        const numPages = pdf.numPages;

        // Render first page immediately
        container.className = 'pages';
        container.innerHTML = '';
        pageInfo.style.display = 'block';
        pageInfo.textContent = `${numPages} หน้า`;

        renderedCanvases = [];
        const firstPage = await pdf.getPage(1);
        const firstCanvas = await renderPage(firstPage, 1);
        container.appendChild(firstCanvas);
        renderedCanvases.push(firstCanvas);
        loading.style.display = 'none';

        // Lazy load remaining pages
        for (let i = 2; i <= numPages; i++) {
          const page = await pdf.getPage(i);
          const canvas = await renderPage(page, i);
          container.appendChild(canvas);
          renderedCanvases.push(canvas);
        }
      } catch (err) {
        console.error('PDF load error:', err);
        loading.style.display = 'none';
        container.style.flex = '1';
        container.style.display = 'flex';
        container.innerHTML = `<iframe src="${url}" style="flex:1;border:none;width:100%;"></iframe>`;
      }
    }

    async function saveAsImage() {
      const overlay = document.getElementById('dlOverlay');
      const dlText = document.getElementById('dlText');
      overlay.classList.add('show');

      try {
        if (isImageFile) {
          // For image files, download the image directly
          dlText.textContent = 'กำลังบันทึกรูปภาพ...';
          const url = `${apiBase}/api/view/${encodeURIComponent(fileId)}`;
          const res = await fetch(url);
          const blob = await res.blob();
          const ext = blob.type.includes('png') ? 'png' : 'jpg';
          triggerBlobDownload(blob, `${docName}.${ext}`);
          overlay.classList.remove('show');
          showToast('บันทึกรูปภาพสำเร็จ');
          return;
        }

        if (renderedCanvases.length === 0) {
          overlay.classList.remove('show');
          showToast('ไม่มีเอกสารให้บันทึก');
          return;
        }

        if (renderedCanvases.length === 1) {
          // Single page — save directly
          dlText.textContent = 'กำลังบันทึกรูปภาพ...';
          const blob = await canvasToBlob(renderedCanvases[0]);
          triggerBlobDownload(blob, `${docName}.png`);
          overlay.classList.remove('show');
          showToast('บันทึกรูปภาพสำเร็จ');
          return;
        }

        // Multiple pages — stitch into one tall image
        dlText.textContent = `กำลังรวม ${renderedCanvases.length} หน้า...`;
        const blob = await stitchPages(renderedCanvases);
        triggerBlobDownload(blob, `${docName}.png`);
        overlay.classList.remove('show');
        showToast('บันทึกรูปภาพสำเร็จ');

      } catch (err) {
        console.error('Save error:', err);
        overlay.classList.remove('show');

        // Fallback: open view URL in external browser
        try {
          const url = `${apiBase}/api/view/${encodeURIComponent(fileId)}`;
          if (typeof liff !== 'undefined' && liff.isInClient()) {
            liff.openWindow({ url, external: true });
            showToast('เปิดในเบราว์เซอร์เพื่อบันทึก');
          } else {
            window.open(url, '_blank');
          }
        } catch (e2) {
          showToast('ไม่สามารถบันทึกได้');
        }
      }
    }

    function canvasToBlob(canvas) {
      return new Promise((resolve) => {
        canvas.toBlob(blob => resolve(blob), 'image/png');
      });
    }

    async function stitchPages(canvases) {
      // Calculate total height and max width
      const maxWidth = Math.max(...canvases.map(c => c.width));
      const totalHeight = canvases.reduce((sum, c) => sum + c.height, 0);

      const stitched = document.createElement('canvas');
      stitched.width = maxWidth;
      stitched.height = totalHeight;
      const ctx = stitched.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, maxWidth, totalHeight);

      let y = 0;
      for (const c of canvases) {
        const x = Math.floor((maxWidth - c.width) / 2);
        ctx.drawImage(c, x, y);
        y += c.height;
      }

      return canvasToBlob(stitched);
    }

    function triggerBlobDownload(blob, fileName) {
      const blobUrl = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = blobUrl;
      a.download = fileName;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        URL.revokeObjectURL(blobUrl);
        document.body.removeChild(a);
      }, 3000);
    }

    (async () => {
      try {
        const liffId = window.LIFF_ID || '';
        if (liffId) await liff.init({ liffId });
        if (liff.isLoggedIn()) {
          const profile = await liff.getProfile();
          userName = profile.displayName || '';
        }
      } catch (e) {
        console.warn('LIFF init skipped:', e);
      }

      if (!fileId) {
        document.getElementById('loadingScreen').innerHTML =
          '<div style="color:#e74c3c;">ไม่พบรหัสเอกสาร</div>';
        return;
      }

      const viewUrl = `${apiBase}/api/view/${encodeURIComponent(fileId)}`;

      if (mode === 'download') {
        // Direct save mode
        await loadPDF(viewUrl);
        await saveAsImage();
        return;
      }

      await loadPDF(viewUrl);
    })();
  </script>
</body>
</html>
